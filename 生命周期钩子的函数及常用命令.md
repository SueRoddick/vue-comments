Vue.js的生命周期函数 beforeCreate、create 、beforeMount 、mounted 、beforeUpdate 、update 、beforeDestroy、destroy

常用指令v-model 、v-if 、v-show 、v-else 、v-bind 、v-on 、v-for 、v-once等

#一、生命周期函数

##vue的生命周期

###vue的生命周期，首先需要注意几个关键字

　　1. el :选择器

　　2. $el：对应选择器的template模板（html代码）

　　3. render：也是vue实例中的一项，其参数更接近vue解析器，按优先级，render参数 > vue实例对象中有template > 外部的HTML模板 后面两个也是将其编译成render函数

　　4. $mount ：当Vue实例没有el属性时，则该实例尚没有挂载到某个dom中，假如需要延迟挂载，可以在之后手动调用vm.$mount()方法来挂载。
  
  例如：new Vue({内部无el项}).$mount('#app')是延迟加载，等同于
     new Vue({el:"#app",***})
     
 ###各个生命周期  beforecreate》created》beforeMount》mounted》beforeDestroy
	 
```
    1.beforeCreate 创建前执行（数据还没有监听，没有绑定到vue对象实例，同时也没有挂载对象，data和el都还未初始化）    
    2.create 完成创建 （数据已经绑定到了对象实例，但是还没有挂载对象，完成了data数据初始化，el还未初始化）    
    3.beforeMount 载入前（模板已经编译好了，根据数据和模板已经生成了对应的元素对象，将数据对象关联到了对象的 $el属性，$el属性是一个HTMLElement对象，也就是这个阶段，vue实例通过原生的createElement等方法来创建这个html片段，准备注入到我们vue实例指明的el属性所对应的挂载点，（完成了data和el数据初始化） ）
    4.mounted 载入后html已经渲染(将$el的内容挂载到了el，相当于我们在jquery执行了$(el).html($el),生成页面上真正的dom，上面我们就会发现dom的元素和我们$el的元素是一致的。在此之后，我们能够用方法来获取到el元素下的dom对象，并进 行各种操作，ajax请求可以放在这个函数中)    
    5.beforeUpdate 更新前状态（数据更新到dom之前，我们可以看到$el对象已经修改，但是我们页面上dom的数据还没有发生改变，view层的数据变化前，不是data中的数据改变前）    
    6.update 更新状态后（dom结构会通过虚拟dom的原则，找到需要更新页面dom结构的最小路径，将改变更新到dom上面，完成更新）
    7.beforeDestroy 销毁前
    8.destroy 销毁后 （Dom元素存在，只是不再受vue控制）
   ```
   
   ```
    其他：
    1、在beforeCreate和created之间：在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）
    
    2、created和beforeMount之间：首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。再次判断template参数选项的有无（因为vue需要通过el找到对应的outer template）：    
（1）如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。
（2）如果没有template选项，则将外部HTML作为模板编译。
（3）可以看到template中的模板优先级要高于outer HTML的优先级。
如果没有template,则通过render传人的createElement编译
综合排名优先级：render函数选项 > template选项 > outer HTML.

3、beforeMount和mounted之间：给vue实例对象添加$el成员，并且替换掉挂在的DOM元素

4、beforeUpdate和update之间：当vue发现data中的数据发生了改变，会触发对应组件的重新渲染（重新渲染虚拟 dom,并通过 diff 算法对比 vnode 节点差异更新真实 dom (virtual DOM re-render and patch)），先后调用beforeUpdate和updated钩子函数（beforeUpdate：可以监听到data的变化但是view层没有被重新渲染，view层的数据没有变化，updated： view层才被重新渲染，数据更新。此处可回顾下react对更新函数。

 beforeDestroy，destroy实例的销毁，vue实例还是存在的，只是解绑了事件的监听还有watcher对象数据与view的绑定，即数据驱动
 ```
```
 var vm=new Vue({
               el:'#date',
		data:{
			data:['a','b','c','d'],
			judge:false,
			judgeT:true,
			uname:'111',
			url:'http://baidu.com',
	},
	methods:{
		alertSrt:function(){
			alert('str');
		},
		alertNum:function(){
			alert('num');
			this.judgeT=false;
		},
		alertUame:function(){
			alert(this.uname);
		}
	},
	beforeCreate:function(){
		alert('创建前');
	},
	create:function(){
		alert('创建完成');
	},
	beforeMount:function(){
		alert('载入前');
	},
	mounted:function(){
		alert('载入后');
	},
	beforeUpdate:function(){
		alert('更新前');
	},
	update:function(){
		alert('更新后');
	}
 
})

```

#二、指令
    1.v-model  接收用户输入的一些数据，直接就可以将这些数据 挂载到data属性里面
    2.v-if  判断加载固定的内容，若为真加载，为假时删除元素,常用在用在权限管理，页面模块条件加载
    3.v-show 元素会始终渲染并保持在dom中，v-show用法和v-if相同，安全性没有v-if高，v-show将元素display设置成none，并不是将元素直接移除。
    4.v-else 元素必须紧跟在v-if或v-show元素的后面——否则它不能被识别
    5.v-bind 给页面中html属性进行绑定
    6.v-on 对页面中的事件进行绑定
      事件修饰符 .stop (阻止单击事件冒泡)   .prevent (提交事件不再重载页面) .capture (使用事件捕获模式) .self(只当事件在该元素本身（而不是子元素）触发时触发回调)
    7.v-for 控制html元素的循环，实现数据列表的生成
    8.v-once 只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。 
